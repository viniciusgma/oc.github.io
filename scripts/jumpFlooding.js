function jumpFlooding(samplePoints, width, height) {
    /**
     * Jump flooding algorithm to calculate the closest sample point for each
     * pixel of the image.
     * 
     * @param {Array<Array<number>>} samplePoints - List of points in format `[[x1, y1], [x2, y2], ...]`.
     * @param {number} width - Image width.
     * @param {number} height - Image height.
     * @returns {Array<Array<number>>} - Grid that saves, for each pixel, the closest sample point label.
     */

    function getNeighbors(x, y, step, width, height) {
        const distances = [-step, 0, step];
        const neighbors = [];

        distances.forEach(dx => {
            let nx = x + dx;
            distances.forEach(dy => {
                let ny = y + dy;
                // check if calculated neighbor is inside the image
                if (nx >= 0 && ny >= 0 && nx < width && ny < height) {
                    neighbors.push([Math.floor(nx), Math.floor(ny)]);
                }
            });
        });
        return neighbors;
    }

    function euclideanDistance(px1, px2) {
        return Math.sqrt(Math.pow(px1[0]-px2[0], 2)+Math.pow(px1[1]-px2[1], 2));
    }

    function buildGrid(samplePoints, width, height) {
        const grid = Array.from({ length: height }, () => Array(width));
        samplePoints.forEach((point, i) => {
            x = Math.floor(point[0]);
            y = Math.floor(point[1]);

            grid[x][y] = String(i);
        });
        return grid;
    }

    function buildSeedsMap(samplePoints) {
        const map = {};
        samplePoints.forEach((point, i) => {
            map[i] = point;
        });
        return map;
    }

    // First step lenght
    const maxStep = Math.floor(Math.max(width, height) / 2);

    // The grid to be processed
    const grid = buildGrid(samplePoints, width, height);

    // A map of the sample points by their respective labels
    const seedsMap = buildSeedsMap(samplePoints);

    // Store the new seeds that will be generated by the algorithm
    const newSeeds = structuredClone(samplePoints);
    
    for (let step = maxStep; step >= 1; step = Math.floor(step/2)) {
        const currentSeeds = structuredClone(newSeeds);
        currentSeeds.forEach(seed => {
            const seedX = Math.floor(seed[0]);
            const seedY = Math.floor(seed[1]);

            const neighbors = getNeighbors(seedX, seedY, step, width, height);

            neighbors.forEach(neighbor => {
                const x = neighbor[0];
                const y = neighbor[1];

                // If neighbor still doens't have a label, then it receives
                // the label of the current seed.
                if (grid[x][y] == undefined) {
                    grid[x][y] = grid[seedX][seedY];
                    newSeeds.push(neighbor);
                } else {
                    // Obtain the neighbor's original seed coordinate
                    const originalSeed = seedsMap[grid[x][y]];
                    const distanceFromOriginalSeed = euclideanDistance(neighbor, originalSeed);

                    // Obtain the currents seed's original seed coordinate
                    const currentSeed = seedsMap[grid[seedX][seedY]];
                    const distanceFromCurrentSeed = euclideanDistance(neighbor, currentSeed);
                    
                    // Set the closest seed label
                    if (distanceFromCurrentSeed < distanceFromOriginalSeed) {
                        grid[x][y] = grid[seedX][seedY];
                    }
                }
            });
        });
    }

    return grid;
}